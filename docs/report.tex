\documentclass[dvipdfmx,a4j,10pt]{jarticle}

\usepackage[hyphens]{url}
\usepackage[top=22truemm,bottom=22truemm,left=20truemm,right=20truemm]{geometry}

\usepackage{tcolorbox}
\newtcbox{\code}[1][]{
  colback=gray!10!white,
  colframe=gray!20!white,
  boxrule=1pt,
  left=0mm,right=0mm,top=0mm,bottom=0mm,
  box align=base,
  nobeforeafter,
  fontupper=\ttfamily
}

\begin{document}

\title{整数の集合を効率的に管理するデータ構造}
\author{$2$ 年 $4$ 組 $20$ 番 児玉大樹}
\date{}
\maketitle

\section{はじめに}

プログラミング言語 C++ には、全順序集合を効率的に管理するためのデータ構造として、
標準ライブラリに \code{std::set} が実装されている。
\code{std::set} の各種操作にかかる時間計算量は、要素数を $N$ として $\Theta (\log N)$ だが、
管理する集合があらかじめ上界の与えられた非負整数の集合ならば、van Emde Boas tree（以下、vEB tree と略記する）と呼ばれるデータ構造を用いてより高速に操作を行うことができる。
本稿では、vEB tree を実装し、\code{std::set} と性能を比較する。

\section{導入}

\subsection{計算量}

\textbf{計算量}は、アルゴリズムやデータ構造の効率を評価するための尺度であり、\textbf{ランダウ記法}を用いて「入力サイズ $n$ に対し、このアルゴリズムは時間計算量 $O(n)$ で動作する」のように記述される。
以下に本稿で用いるランダウ記法の定義を示す。

\begin{itemize}
  \item 
    $f(n) = O(g(n))$ であるとは、ある定数 $C$ および自然数 $n_0$ が存在して、
    $n_0$ より大きい任意の自然数 $n$ に対し $|f(n)| \leq C|g(n)|$ が成り立つことをいう。
  \item 
    $f(n) = \Omega(g(n))$ であるとは、ある定数 $C$ および自然数 $n_0$ が存在して、
    $n_0$ より大きい任意の自然数 $n$ に対し $|f(n)| \geq C|g(n)|$ が成り立つことをいう。
  \item 
    $f(n) = \Theta(g(n))$ であるとは、
    $f(n) = O(g(n))$ かつ $f(n) = \Omega(g(n))$ であることをいう。
\end{itemize}

\subsection{全順序集合に対する操作}

管理する集合を $S$ とおく。本稿では、以下の $5$ つの操作を扱う。

\begin{itemize}
  \item $\mathrm{INSERT}(x)$ \mbox{}\\
    $x \notin S$ ならば $S$ に $x$ を追加する。$x \in S$ ならば何もしない。
  \item $\mathrm{DELETE}(x)$ \mbox{}\\
    $x \in S$ ならば $S$ から $x$ を取り除く。$x \notin S$ ならば何もしない。
  \item $\mathrm{MEMBER}(x)$ \mbox{}\\
    $x \in S$ かどうか判定する。
  \item $\mathrm{PREDECESSOR}(x)$ \mbox{}\\
    $S$ に含まれる $x$ 以下の要素のうち最大のものを求める。
    存在しないならばそのことを報告する。
  \item $\mathrm{SUCCESSOR}(x)$ \mbox{}\\
    $S$ に含まれる $x$ 以上の要素のうち最小のものを求める。
    存在しないならばそのことを報告する。
\end{itemize}

\subsection{集合に対する制約}

vEB tree を適用するため、ある自然数 $U$ が存在して、$S$ は $\{0, 1, \dots, U-1\}$ の部分集合であると仮定する。
この $U$ を\textbf{普遍集合サイズ}と呼ぶ。
vEB tree の計算量は $U$ に依存する。

\section{\code{std::set} の仕組み}

\subsection{二分木}

\textbf{二分木}とは、根付き木であって、全ての頂点が高々 $2$ つの子を持つものである。
$2$ つの子はそれぞれ\textbf{左の子}、\textbf{右の子}と呼ばれる。
頂点がただ $1$ つの子を持つ場合、左の子、右の子のうちいずれか一方の子を持つ。

\subsection{二分探索木}

\textbf{二分探索木}とは、二分木であって、頂点に値が対応しており、
全ての頂点 $n$ について以下の条件がいずれも成り立つものである。

\begin{itemize}
  \item $n$ の左の子が存在するならば、その値は $n$ の値以下である。
  \item $n$ の右の子が存在するならば、その値は $n$ の値以上である。
\end{itemize}

\subsection{平衡二分探索木}

二分探索木は、頂点数を $N$ とおくと、深さが最大で $\Theta(N)$ になる。
二分探索木の条件を保ったまま、深さを小さく維持しようとするのが\textbf{平衡二分探索木}である。
\code{std::set} は平衡二分探索木を用いて実装されている。

\code{std::set} の最悪時間計算量は、集合の要素数を $N$ として $\Theta(\log N)$ である。
また、空間計算量は $\Theta(N)$ である。

\section{vEB tree}

\subsection{vEB tree の構造}

簡単のため $U = 2^K$ とする。
$K \leq 1$ すなわち $U \leq 2$ のときは、長さ $U$ の配列を用いて、$x = 0, \dots, U - 1$ それぞれについて $x \in S$ かどうかを管理しておくことにより、全ての操作を $O(1)$ の計算量で行うことができる。
以降は $K \geq 2$ とする。

$U_{\mathrm{low}} = 2^{\left\lfloor \frac{K}{2} \right\rfloor}, 
U_{\mathrm{high}} = 2^{\left\lceil \frac{K}{2} \right\rceil}$ とおく。
普遍集合サイズ $u$ の vEB tree を $\mathrm{vEB}(u)$ と表すことにすると、
$\mathrm{vEB}(U)$ は以下の情報から構成される。

\begin{itemize}
  \item $\mathrm{min}$ : $S$ の最小値（存在しない場合は $\mathrm{NIL}$）
  \item $\mathrm{max}$ : $S$ の最大値（存在しない場合は $\mathrm{NIL}$）
  \item $\mathrm{cluster}$ : $U_{\mathrm{high}}$ 個の $\mathrm{vEB}(U_{\mathrm{low}})$ を指すポインタ
  \item $\mathrm{summary}$ : $\mathrm{cluster}$ の情報をまとめた $\mathrm{vEB}(U_{\mathrm{high}})$
\end{itemize}

以下、$i = 0, \dots, U_{\mathrm{high}} - 1$ に対し、$\mathrm{cluster}_i$ で $i + 1$ 番目のポインタが指す $\mathrm{vEB}(U_{\mathrm{low}})$ を表すことにする。
また、$x \in \{0, \dots, U - 1\}$ に対し、$x$ を $U_{\mathrm{low}}$ で割った商を $\mathrm{high}(x)$、余りを $\mathrm{low}(x)$ とおく。

$\mathrm{cluster}_0, \dots, \mathrm{cluster}_{U_{\mathrm{high}} - 1}$ は $S \setminus \{\mathrm{min}\}$ の要素を管理する。
$x \in S \setminus \{\mathrm{min}\}$ は、$\mathrm{cluster}_{\mathrm{high}(x)}$ 内に $\mathrm{low}(x)$ として管理する。

$\mathrm{summary}$ は $i \in \{0, \dots, U_{\mathrm{high}} - 1\}$ かつ $\mathrm{cluster}_i$ が管理する集合が空でないような $i$ の集合を管理する vEB tree である。

\subsection{各種操作の実現}

\subsubsection{$\mathrm{INSERT}(x)$}

\subsubsection{$\mathrm{DELETE}(x)$}

\subsubsection{$\mathrm{MEMBER}(x)$}

\subsubsection{$\mathrm{PREDECESSOR}(x)$}

\subsubsection{$\mathrm{SUCCESSOR}(x)$}

\end{document}